# Task17_12

Задача 4. Сортировки
В некоторых вариантах данной задачи требуется реализовать сортировки, которые на 
лекции не были рассмотрены. В этом случае вы должны найти информацию о требуемых 
сортировках и разобраться самостоятельно (в Интернете по сортировкам полно различной 
информации, более того, в большинстве случаев есть готовые реализации сортировок, 
единственное, возможно не на Java, а на других языках).
Если вы берете и адаптируете под свою задачу какую-то готовую реализацию 
сортировки, вы обязательно должны разобраться, как данная сортировка работает, и быть в 
состоянии объяснить алгоритм работы преподавателю.
Если в условии задачи что-то непонятно – попросить пояснить преподавателя

(*) Написать программу, которая иллюстрирует работу сортировки пузырьком (Bubble 
sort) на примере массива целых чисел. Для описания текущего состояния сортировки 
должен быть описан класс SortState, в котором будут храниться:
– массив (текущее состояние на данном шаге, естественно, надо делать копию 
массива, т.к. исходный массив будет меняться в процессе сортировки);
– переменная цикла i;
– переменная вложенного цикла j;
– возможно еще какие-то данные, необходимые для визуализации.
В модифицированной процедуре сортировки помимо соответствующих действий на 
каждом шаге необходимо создать экземпляр класса SortState, соответствующий 
текущему шагу сортировки, и добавлять этот экземпляр в список состояний, который 
будет возвращаться, т.е. сортировка будет иметь следующую сигнатуру:
List<SortState> sort(int[] arr)
Далее необходимо реализовать наглядное отображение на форме состояния SortState 
(возможно с использованием JTable или нарисовать). К таймеру следует привязать 
обработчик событий, который будет обновлять форму (перерисовывать очередное 
состояние в процессе сортировки).
Таким образом, непосредственно сортировка выполняется сразу же, а отображение на 
форме произошедших событий осуществляется позже с задержками, чтобы пользователь 
мог оценить, что происходит.
Предусмотреть режим, когда таймер отключается и очередное состояние отображается 
по нажатию кнопки (причем, чтобы можно было «проигрывать» события как вперед, так 
и назад)
  
  (*) Предыдущая задача, но для гномьей сортировки (Gnome sort).
